<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- jquery -->
    <script src="//unpkg.com/jquery/dist/jquery.min.js"></script>
    <!-- cytoscape -->
    <script src="//unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    <!-- dagre layout -->
    <script src="//unpkg.com/dagre/dist/dagre.min.js"></script>
    <script src="//unpkg.com/cytoscape-dagre/cytoscape-dagre.js"></script>
    <!-- qtip -->
    <link rel="stylesheet" type="text/css" href="//unpkg.com/qtip2/dist/jquery.qtip.min.css">
    <script src="//unpkg.com/qtip2/dist/jquery.qtip.min.js"></script>
    <script src="//unpkg.com/cytoscape-qtip/cytoscape-qtip.js"></script>
    <!-- molstar -->
    <link rel="stylesheet" type="text/css" href="css/molstar.css">
    <script type="text/javascript" src="js/molstar.js"></script>

    <title>Scipion workflow</title>

</head>
<body>
</body>

<dom-module id="scipion-workflow">

    <style>

        #cy {
            z-index: 999;
        }

        .qtip {
            max-width: 50%;
        }

        .qtip-tip {
            display: none !important;
        }

        .qtip-content{
            overflow-x: scroll;
            overflow-y: scroll;
            height: 50vh;
        }

        .msp-plugin {
            background: none;
        }

        .msp-plugin-content {
            margin-top: 20vh;
            margin-bottom: 20vh;
            margin-right: 20vh;
            margin-left: 20vh;
        }

        .images {
            display: none;
            margin-top: 10px;
        }

        .toggle-icon {
            cursor: pointer;
            font-size: 16px;
            user-select: none;
        }

    </style>

    <script>

        function getRandomHexColor() {
        // Returns random hexadecimal color
            const randomColor = Math.floor(Math.random() * 16777215).toString(16);
            return `#${randomColor.padStart(6, '0')}`;
        }

        function getFormattedProtocolStr(dict, viewMode){
            // Formats a protocol object to show its data in the qtip as a table
            // Returns the table as a html string.
            var blackList = ['runName', 'runMode', 'labelColor']; // Params given by scipion json that we dont want to show
            var summaryWhiteList = ['object.className', 'summary', 'output']
            var formattedStr = '<table><th>Param name</th><th>Param value</th>';

            $.each(dict, function(key, value){
                if (blackList.indexOf(key)===-1){
                    if(viewMode!=='summarized' || summaryWhiteList.indexOf(key)!==-1) {
                        if (key === 'output') { // images
                            formattedStr += '<tr><td><b>' + 'output' + ':</b></td><td></td></tr>'
                            $.each(value, function(outputKey, outputValue){
                                formattedStr += '<tr><td class="toggle-icon" onclick="toggleImages(' + "'" + outputValue['outputName'] + "'" + ', this)"> ▼ -' + outputValue['outputName'] + ':</td><td class="images" id="' + outputValue['outputName'] + '"> ';
                                var outputItems = outputValue['outputItems']
                                var nimg = 0
                                var nvol = 0

                                $.each(outputItems, function(itemKey, itemValue) {
                                    if ('item_representation' in itemValue) {
                                        var paths = itemValue['item_representation']

                                        if (Array.isArray(paths)){ // is a folder containing images inside
                                            $.each(paths, function(index, path) {
                                                path = path.substring(path.lastIndexOf('/', path.lastIndexOf('/') - 1) + 1);
                                                if (path.indexOf('jpg')!==-1){
                                                    if (path.indexOf('slicesX_0000') !== -1) {
                                                        volume_name = path.substring(1, path.lastIndexOf("/"))
                                                        formattedStr += '<hr><b style="color: #29808A;">' + volume_name + '</b>' + '<br><br>';
                                                        formattedStr += '<b>Slices X axis:</b>' + '<br><br>';
                                                    }
                                                    if (path.indexOf('slicesY_0000') !== -1) {
                                                        formattedStr += '<hr>' + '<b>Slices Y axis:</b>' + '<br><br>';
                                                    }
                                                    if (path.indexOf('slicesZ_0000') !== -1) {
                                                        formattedStr += '<hr>' + '<b>Slices Z axis:</b>' + '<br><br>';
                                                    }
                                                    formattedStr += '<img data-src=' + "images_representation/" + path + ' style="margin: 0px 0px 10px 5px; max-width:100px;" class="zoom ' + outputValue['outputName'] + '">'

                                                    nimg = nimg + 1;
                                                    if (nimg % 5 == 0) {
                                                        formattedStr += '<br>';
                                                    }
                                                }
                                            });
                                        }

                                        else {
                                            path = paths.substring(paths.lastIndexOf("/") + 1, paths.length)

                                            if (path.indexOf('jpg')!==-1){ // is a single jpg image
                                                formattedStr += '<img data-src=' + "images_representation/" + path + ' style="margin: 0px 0px 10px 5px; max-width:100px;" class="zoom ' + outputValue['outputName'] + '">'
                                                nimg = nimg + 1;
                                                if (nimg % 5 == 0) {
                                                    formattedStr += '<br>';
                                                }
                                            }

                                            else if (path.indexOf('mrc')!==-1 || path.indexOf('map')!==-1){ // open volume with Molstar
                                                if (nvol == 0) {
                                                    formattedStr += '<div id-src="app_' + path + '" class="' + outputValue['outputName'] + '"></div>';
                                                    color = parseInt(getRandomHexColor().replace('#', '0x'));
                                                    formattedStr += '<script type="text/javascript"> molstar.Viewer.create("app_' + path + '", {layoutShowControls: true, viewportShowExpand: false, collapseLeftPanel: true, collapseRightPanel: false,}).then(viewer => {viewer.loadVolumeFromUrl({url:' + '"images_representation/' + path + '",format: "ccp4",isBinary: true}, [{type: "relative",value: 1.5,color: ' + color + '}]);';
                                                    nvol = nvol + 1;
                                                }
                                                else {
                                                    formattedStr += 'viewer.loadVolumeFromUrl({url:' + '"images_representation/' + path + '",format: "ccp4",isBinary: true}, [{type: "relative",value: 1.5,color: 0x29808A}]);'
                                                }
                                            }
                                        }
                                    }
                                    if (outputValue['outputType'] === 'SetOfClasses3D' ) {
                                        formattedStr += '<br>';
                                    }
                                });

                                if (nvol > 0) {
                                    formattedStr += '});'
                                    formattedStr += '<\u002Fscript>';
                                }

                                formattedStr += '</td></tr>'
                                if (outputValue['outputType'] === 'SetOfClasses2D' || outputValue['outputType'] === 'SetOfClasses3D') {
                                    formattedStr += '<tr><td></td><td>' + outputValue['outputSize'] + ' classes';
                                    formattedStr +=  '</td></tr>';
                                }
                            });
                        }
                        else {
                            formattedStr += '<tr><td><b>' + key + ':</b></td><td title="' + value + '">' + value + '</td></tr>'
                        }
                    }
                }
            });
            formattedStr += '</table>';
            return formattedStr
        }

        function paintGraph(workflowDiv, nodes, edges){
            // Paints the graph inside a given container (workflowDiv).
            // Needs nodes and edges as returned by getGraphNodes function
            var cy = cytoscape({
              container: workflowDiv,
              autounselectify: true,
              zoom: 1,
              minZoom: 1e-50,
              maxZoom: 1e50,
              wheelSensitivity: 1,

              layout: {
                name: 'dagre',
                padding: 10,
                nodeSep: 10
              },

              style: cytoscape.stylesheet()
                .selector('node')
                  .style({
                    'shape': 'rectangle',
                    'width': 'label',
                    'padding': 5,
                    'content': 'data(name)',
                    'text-valign': 'center',
                    'background-fill': 'linear-gradient',
                    'background-gradient-stop-colors': 'data(color)',
                    'color': '#393939'
                  })
                .selector(':selected')
                  .style({
                    'border-width': 2,
                    'border-color': '#333'
                  })
                .selector('edge')
                  .style({
                    'opacity': 1,
                    'width': .5,
                    'line-color': 'grey',
                  })
                .selector('edge:selected')
                  .style({
                    'width': 1,
                    'border-color': '#333',
                    'line-color': 'grey'
                  })
                .selector('.faded')
                  .style({
                    'opacity': 0.25,
                    'text-opacity': 0
                  }),

              elements: {
                nodes: nodes,
                edges: edges
              }
            });

            var currentId;
            // just use the regular qtip api but on cy elements
            cy.nodes().qtip({
                content: {
                    text: function(){currentId = this.data().id;return this.data().content},
                    title: {
                        text: function(){
                            var title;
                            cy.nodes().forEach(function(node) {
                                if (node.data().id === currentId) {
                                    title = node.data().name
                                }
                            });
                            return title
                        },
                        button: true
                    }
                },
                position: {
                    my: 'bottom center',
                    at: 'top center'
                },
                style: {
                    classes: 'qtip-bootstrap'
                }
            });

        }

        function getWorkflow(jsonSrc, workflowDiv){
            // Parses json from jsonSrc and paints workflow in workflowDiv
            // (workflowDiv must be an html element)

            var viewModeSelector = document.getElementById('view-mode');
            var viewModeValue = viewModeSelector.options[viewModeSelector.selectedIndex].value;

            if (jsonSrc.startsWith("[")){
                getGraphNodes(JSON.parse(jsonSrc), workflowDiv, viewModeValue);

            }else{
                $.getJSON(jsonSrc, function (data , status){
                    getGraphNodes(data, workflowDiv, viewModeValue);
                });
            }
        }

        function getGraphNodes(data, workflowDiv, viewMode){
                // Parses json data as given by getWorkflow function
                var nodeList = [{ data: {
                                            id: 'root',
                                            name: 'Project',
                                            color: '#EEEEEE'
                                        }
                                }
                    ];
                var edgeList = [];
                var regex = /^(\d+)\./;
                const labels = {no_label: '#EEEEEE'};

                $.each(data, function(index, protocol){
                    var color = '#EEEEEE'

                    if (protocol['labelColor'] != undefined && protocol['labelColor'].length > 0) {
                        color = protocol['labelColor'][0];
                        labels[protocol['label'][0]] = color;
                    }

                    // if there is no object.label for this protocol, use the object.className instead
                    var name = protocol['object.label'] && protocol['object.label'].trim() !== '' ? protocol['object.label'] : protocol['object.className'];

                    nodeList.push({ data: {
                                            id: protocol['object.id'],
                                            name: name,
                                            content: getFormattedProtocolStr(protocol, viewMode),
                                            color: color
                    }
                    });
                    var hasInputs = false;
                    $.each(protocol, function(key, value){
                        var protID = protocol['object.id'];
                        if (Array.isArray(value)){
                            $.each(value, function(index, arrayValue){
                                if (typeof(arrayValue) === 'string' && regex.test(arrayValue) && key !== 'pluginVersion' && key !== 'pluginBinaryVersion'){
                                    edgeList.push({ data: {
                                                        source: arrayValue.split('.')[0],
                                                        target: protID
                                                        }
                                                  });
                                    hasInputs = true
                                }

                            })
                        }else if (typeof(value) === 'string' && regex.test(value) && key !== 'pluginVersion' && key !== 'pluginBinaryVersion'){
                            edgeList.push({ data: {
                                                source: value.split('.')[0],
                                                target: protID
                                                }
                                          });
                            hasInputs = true
                        }
                    });
                    if (!hasInputs){
                            edgeList.push({ data: {
                                                source: 'root',
                                                target: protocol['object.id']
                                                }
                                          });
                    }

                });
                paintGraph(workflowDiv, nodeList, edgeList);
                if (Object.keys(labels).length > 1) {
                    paintLabels(labels);
                }
        };

        function toggleImages(id, element) {

            var imgRow = document.getElementById(id);
            var icon = element;
            var currentHtml = icon.innerHTML;

            if (imgRow.style.display === 'none' || imgRow.style.display === '') {
                imgRow.style.display = 'table-row';
                icon.innerHTML = currentHtml.replace("▼", "▲");
            } else {
                imgRow.style.display = 'none';
                icon.innerHTML = currentHtml.replace("▲", "▼");
            }

             // actually load jpg images or mrc volumes. Avoids loading all protocol thumbnails at once
            if (id.indexOf('3D')!==-1){ // is a 3d volume

                const volume = document.getElementsByClassName(id)[0];
                volume.id = volume.getAttribute('id-src');

                // get element and reload molstar javascript code
                var td = document.getElementById(id);
                var molstarScriptElement = td.querySelector('script');
                var molstarScriptCode = molstarScriptElement.textContent || molstarScriptElement.innerText;

                molstarScriptElement.remove();
                var newMolstarScriptElement = document.createElement('script');
                newMolstarScriptElement.textContent = molstarScriptCode;
                td.appendChild(newMolstarScriptElement);

            }
            else { // is a jpg image

                const images = document.getElementsByClassName(id);

                for (let i = 0; i < images.length; i++) {
                    const image = images[i];
                    image.src = image.getAttribute('data-src');
                }
            }
        };

        function paintLabels(labels) {

            // Helper function to convert rgb to hex
            function rgbToHex(rgb) {
                const result = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                if (!result) return null;
                const r = parseInt(result[1], 10);
                const g = parseInt(result[2], 10);
                const b = parseInt(result[3], 10);
                const hex = (r << 16) | (g << 8) | b;
                return '#' + hex.toString(16).padStart(6, '0').toUpperCase();
            }

            // Helper function to check if a div with the same background color exists
            function colorExists(color) {
                const divs = legend.querySelectorAll('.legend_square');
                for (const div of divs) {
                    const divColor = getComputedStyle(div).backgroundColor;
                    if (rgbToHex(divColor) === color) {
                        return true;
                    }
                }
                return false;
            }

            const legend = document.getElementById('legend');
            const b = document.createElement('b');
            b.textContent = 'Labels legend:'
            legend.appendChild(b);

            Object.entries(labels).forEach(([key, value]) => {

                if (!colorExists(value)) {
                    const li = document.createElement('li');
                    li.className = 'legend_item_square';

                    const div = document.createElement('div');
                    div.className = 'legend_square';
                    div.style.backgroundColor = value;

                    const span = document.createElement('span');
                    span.className = 'legend_label';
                    span.textContent = key;

                    li.appendChild(div);
                    li.appendChild(span);
                    legend.appendChild(li);
                }
            });
        };

        class ScipionWorkflow extends HTMLElement {
            static get is() { return "scipion-workflow"; }

            // Define attributes to observe
            static get observedAttributes() {return ['src']; }

            // React to attributes changes
            attributeChangedCallback(attr, oldValue, newValue) {
                if (attr == 'src' && newValue !== oldValue) {
                    this.refresh();
                }
            }

            constructor() {
                super();
                // Create a shadow root
                var shadow = this.attachShadow({mode: 'open'});
                // Create a div that will contain the workflow graph
                var workflowDiv = document.createElement('div');
                workflowDiv.id = 'workflowDiv';
                this.workflowDiv = workflowDiv;
                shadow.appendChild(workflowDiv);
                // Paint the graph
                this.refreshCalled = false;
                this.refresh()
            }

            refresh() {
                if (this.refreshCalled) return; // Skip if already called
                this.refreshCalled = true;
                // Performs all the steps to paint the graph

                // 1. Get attrs from the html tag
                var jsonSrc = this.getAttribute('src');
                if (jsonSrc == undefined) {
                    return;
                }
                // 2. Apply attrs to workflow div
                this.workflowDiv.style.width = '100%';
                this.workflowDiv.style.height = '100%';
                this.workflowDiv.style.position = 'relative';
                //3. Parse json data and paint graph
                getWorkflow(jsonSrc, this.workflowDiv);
            }
        }
        customElements.define(ScipionWorkflow.is, ScipionWorkflow);

        // Prevent styles from being applied via html import, add them explicitly to head
        // as specified in https://github.com/TakayoshiKochi/deprecate-style-in-html-imports
        var importDoc = document.currentScript.ownerDocument;
        var styleLink = importDoc.querySelector('link[rel=stylesheet]');
        document.head.appendChild(styleLink);
        var style = importDoc.querySelector('style');
        document.head.appendChild(style);

    </script>
</dom-module>

</html>
